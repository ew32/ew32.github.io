<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTP GET과 POST의 차이점</title>
    <url>/2024/07/16/difference-between-get-and-post-md/</url>
    <content><![CDATA[<h1 id="HTTP-GET과-POST의-차이"><a href="#HTTP-GET과-POST의-차이" class="headerlink" title="HTTP GET과 POST의 차이"></a>HTTP GET과 POST의 차이</h1><p>HTTP 프로토콜에서 GET과 POST는 가장 일반적으로 사용되는 두 가지 요청 메서드입니다. 이 둘은 여러 면에서 다릅니다.</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><ul>
<li><strong>용도</strong>: 데이터를 서버에서 가져올 때 사용됩니다.</li>
<li><strong>파라미터 전송 방식</strong>: URL에 쿼리 스트링 형태로 포함됩니다.</li>
<li><strong>캐싱</strong>: 대부분의 브라우저와 중간 캐시 서버에서 GET 요청에 대한 응답을 캐시합니다.<ul>
<li><strong>캐싱의 이점</strong>: 동일한 요청을 여러 번 보내는 경우, 서버의 부하를 줄이고 응답 속도를 높일 수 있습니다.</li>
<li><strong>캐싱의 작동 방식</strong>: 브라우저는 동일한 URL로 요청을 보낼 때, 서버로부터의 응답이 변경되지 않았다는 것을 확인하면 저장된 캐시된 데이터를 사용합니다.</li>
<li><strong>Cache-Control 헤더</strong>: 서버는 <code>Cache-Control</code> 헤더를 사용하여 클라이언트와 중간 캐시 서버에 캐싱 정책을 전달할 수 있습니다.</li>
</ul>
</li>
<li><strong>데이터 길이</strong>: URL 길이에 제한이 있습니다.</li>
<li><strong>안전성</strong>: 데이터 조회용으로 사용되어 서버의 상태를 변경하지 않습니다.</li>
<li><strong>즐겨찾기</strong>: 요청이 URL에 저장되므로 즐겨찾기에 추가할 수 있습니다.</li>
<li><strong>보안</strong>: URL에 파라미터가 포함되므로 민감한 정보를 전달하기에 적합하지 않습니다.</li>
</ul>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><ul>
<li><strong>용도</strong>: 서버에 데이터를 전송할 때 사용됩니다.</li>
<li><strong>파라미터 전송 방식</strong>: 요청 본문(body)에 포함됩니다.</li>
<li><strong>캐싱</strong>: 기본적으로 캐시되지 않습니다.</li>
<li><strong>데이터 길이</strong>: 전송하는 데이터의 길이에 제한이 없습니다.</li>
<li><strong>안전성</strong>: 주로 데이터 작성, 업데이트, 삭제와 같이 서버의 상태를 변경하는 작업에 사용됩니다.</li>
<li><strong>즐겨찾기</strong>: 요청 본문에 데이터가 포함되므로 즐겨찾기에 추가하기 어렵습니다.</li>
<li><strong>보안</strong>: URL에 파라미터가 포함되지 않으므로 민감한 정보를 전달하기에 더 적합합니다.</li>
</ul>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li>GET 메서드는 데이터 조회에 적합하며, POST 메서드는 데이터 전송 및 서버 상태 변경에 적합합니다.</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>GET</tag>
        <tag>POST</tag>
        <tag>웹 개발</tag>
      </tags>
  </entry>
  <entry>
    <title>클라우드 컴퓨팅 개요</title>
    <url>/2024/07/20/cloud-computing-overview-md/</url>
    <content><![CDATA[<h1 id="클라우드-컴퓨팅의-이해"><a href="#클라우드-컴퓨팅의-이해" class="headerlink" title="클라우드 컴퓨팅의 이해"></a>클라우드 컴퓨팅의 이해</h1><h2 id="클라우드-컴퓨팅의-개념"><a href="#클라우드-컴퓨팅의-개념" class="headerlink" title="클라우드 컴퓨팅의 개념"></a>클라우드 컴퓨팅의 개념</h2><p>클라우드 컴퓨팅은 인터넷을 통해 서버, 저장소, 데이터베이스, 네트워크, 소프트웨어 등을 제공하는 기술이다. 이는 물리적 하드웨어 없이도 다양한 IT 자원을 필요에 따라 사용하고 관리할 수 있게 해준다.</p>
<h2 id="클라우드-컴퓨팅의-유형"><a href="#클라우드-컴퓨팅의-유형" class="headerlink" title="클라우드 컴퓨팅의 유형"></a>클라우드 컴퓨팅의 유형</h2><h3 id="IaaS-Infrastructure-as-a-Service"><a href="#IaaS-Infrastructure-as-a-Service" class="headerlink" title="IaaS (Infrastructure as a Service)"></a>IaaS (Infrastructure as a Service)</h3><p>기본 인프라 자원을 제공한다. 가상화된 컴퓨팅 리소스, 스토리지, 네트워킹 등을 포함한다. 사용자는 운영체제, 애플리케이션 등을 직접 설치하고 관리한다.</p>
<ul>
<li><strong>예시</strong>: Amazon EC2, Google Compute Engine, Azure Virtual Machines</li>
</ul>
<h3 id="PaaS-Platform-as-a-Service"><a href="#PaaS-Platform-as-a-Service" class="headerlink" title="PaaS (Platform as a Service)"></a>PaaS (Platform as a Service)</h3><p>애플리케이션 개발과 배포를 위한 플랫폼을 제공한다. 개발 환경, 데이터베이스, 미들웨어 등을 포함한다. 사용자는 애플리케이션 코드만 작성하고 나머지 인프라는 서비스 제공자가 관리한다.</p>
<ul>
<li><strong>예시</strong>: Google App Engine, Azure App Services, AWS Elastic Beanstalk</li>
</ul>
<h3 id="SaaS-Software-as-a-Service"><a href="#SaaS-Software-as-a-Service" class="headerlink" title="SaaS (Software as a Service)"></a>SaaS (Software as a Service)</h3><p>완전한 애플리케이션을 인터넷을 통해 제공한다. 사용자는 소프트웨어 설치나 유지보수 없이 서비스 이용 가능하다.</p>
<ul>
<li><strong>예시</strong>: Google Workspace, Microsoft Office 365, Salesforce</li>
</ul>
<h2 id="주요-클라우드-제공-업체-비교"><a href="#주요-클라우드-제공-업체-비교" class="headerlink" title="주요 클라우드 제공 업체 비교"></a>주요 클라우드 제공 업체 비교</h2><h3 id="AWS-Amazon-Web-Services"><a href="#AWS-Amazon-Web-Services" class="headerlink" title="AWS (Amazon Web Services)"></a>AWS (Amazon Web Services)</h3><ul>
<li><strong>장점</strong>: 다양한 서비스와 도구, 글로벌 데이터 센터 네트워크, 높은 안정성과 보안</li>
<li><strong>단점</strong>: 가격 구조가 복잡할 수 있음, 초보자에게는 어려울 수 있음</li>
</ul>
<h3 id="Google-Cloud"><a href="#Google-Cloud" class="headerlink" title="Google Cloud"></a>Google Cloud</h3><ul>
<li><strong>장점</strong>: 강력한 데이터 분석 및 머신 러닝 도구, 빠른 네트워크 속도, 경쟁력 있는 가격</li>
<li><strong>단점</strong>: 서비스 종류가 AWS에 비해 적을 수 있음, 일부 지역에서는 지원이 제한될 수 있음</li>
</ul>
<h3 id="Azure-Microsoft-Azure"><a href="#Azure-Microsoft-Azure" class="headerlink" title="Azure (Microsoft Azure)"></a>Azure (Microsoft Azure)</h3><ul>
<li><strong>장점</strong>: Microsoft 제품과의 높은 호환성, 기업용 솔루션 강점, 하이브리드 클라우드 지원</li>
<li><strong>단점</strong>: 복잡한 초기 설정, 일부 서비스의 사용법이 어려울 수 있음</li>
</ul>
<p>각 클라우드 제공 업체는 고유의 강점과 약점을 가지고 있어, 기업의 필요와 목표에 따라 적합한 선택이 필요하다.</p>
]]></content>
      <categories>
        <category>Cloud</category>
        <category>Infrastructure</category>
      </categories>
      <tags>
        <tag>클라우드</tag>
        <tag>AWS</tag>
        <tag>Azure</tag>
        <tag>GCP</tag>
        <tag>IaaS</tag>
        <tag>PaaS</tag>
        <tag>SaaS</tag>
      </tags>
  </entry>
  <entry>
    <title>네트워크 및 디스크 기반 파일 시스템</title>
    <url>/2024/07/08/network-and-disk-based-file-systems-md/</url>
    <content><![CDATA[<h2 id="네트워크-기반-파일-시스템-Network-based-File-System"><a href="#네트워크-기반-파일-시스템-Network-based-File-System" class="headerlink" title="네트워크 기반 파일 시스템(Network-based File System)"></a>네트워크 기반 파일 시스템(Network-based File System)</h2><p>네트워크 기반 파일 시스템은 파일이 로컬 디스크가 아닌 네트워크에 연결된 서버에 저장되는 시스템입니다. 사용자와 애플리케이션은 파일이 로컬에 있는 것처럼 접근할 수 있지만 실제 파일은 네트워크를 통해 접근됩니다. 대표적인 네트워크 기반 파일 시스템으로는 NFS(Network File System), SMB(Server Message Block), 그리고 DFS(Distributed File System) 등이 있습니다.</p>
<h3 id="주요-특징"><a href="#주요-특징" class="headerlink" title="주요 특징"></a>주요 특징</h3><ul>
<li><strong>중앙 집중식 저장</strong>: 모든 파일이 중앙 서버에 저장되어 관리가 용이합니다.</li>
<li><strong>데이터 공유</strong>: 여러 클라이언트가 같은 파일을 공유할 수 있어 협업이 용이합니다.</li>
<li><strong>확장성</strong>: 스토리지 용량을 쉽게 확장할 수 있습니다.</li>
</ul>
<h2 id="디스크-기반-파일-시스템-Disk-based-File-System"><a href="#디스크-기반-파일-시스템-Disk-based-File-System" class="headerlink" title="디스크 기반 파일 시스템(Disk-based File System)"></a>디스크 기반 파일 시스템(Disk-based File System)</h2><p>디스크 기반 파일 시스템은 컴퓨터의 로컬 디스크에 파일을 저장하는 시스템입니다. 이는 물리적 저장 장치에 직접 접근하여 데이터를 읽고 쓰는 방식으로, 운영 체제에 의해 관리됩니다. 대표적인 디스크 기반 파일 시스템에는 NTFS, FAT32, ext4 등이 있습니다.</p>
<h3 id="주요-특징-1"><a href="#주요-특징-1" class="headerlink" title="주요 특징"></a>주요 특징</h3><ul>
<li><strong>로컬 저장</strong>: 파일이 로컬 디스크에 저장되어 빠른 접근 속도를 제공합니다.</li>
<li><strong>보안</strong>: 로컬 디스크의 파일은 네트워크를 통해 접근할 수 없으므로 보안이 뛰어납니다.</li>
<li><strong>제한된 공유</strong>: 파일을 공유하려면 네트워크 설정을 통해 공유 폴더를 만들어야 합니다.</li>
</ul>
<h3 id="디스크-기반-파일-시스템-상세-설명"><a href="#디스크-기반-파일-시스템-상세-설명" class="headerlink" title="디스크 기반 파일 시스템 상세 설명"></a>디스크 기반 파일 시스템 상세 설명</h3><p>디스크 기반 파일 시스템은 데이터를 효율적으로 저장하고 검색할 수 있도록 설계된 구조입니다. 각 파일 시스템은 고유의 구조와 알고리즘을 사용하여 파일과 디렉토리를 관리합니다.</p>
<h4 id="주요-파일-시스템-종류"><a href="#주요-파일-시스템-종류" class="headerlink" title="주요 파일 시스템 종류"></a>주요 파일 시스템 종류</h4><ul>
<li><strong>NTFS(New Technology File System)</strong>: 윈도우 NT 계열 운영 체제에서 사용되는 파일 시스템으로, 보안, 압축, 대용량 파일 지원 등의 기능이 있습니다.</li>
<li><strong>FAT32(File Allocation Table 32)</strong>: 모든 운영 체제에서 호환이 가능하며, 작은 파일 시스템과 USB 드라이브에서 주로 사용됩니다.</li>
<li><strong>ext4(Extended File System version 4)</strong>: 리눅스에서 주로 사용되는 파일 시스템으로, 저널링, 큰 파일 및 파일 시스템 지원, 향상된 성능 등의 기능이 있습니다.</li>
</ul>
<h4 id="파일-시스템의-주요-기능"><a href="#파일-시스템의-주요-기능" class="headerlink" title="파일 시스템의 주요 기능"></a>파일 시스템의 주요 기능</h4><ol>
<li><strong>파일 저장 및 검색</strong>: 파일을 저장하고 필요할 때 빠르게 검색할 수 있도록 구조화된 데이터 저장 방식을 제공합니다.</li>
<li><strong>디렉토리 구조</strong>: 파일을 계층 구조로 구성하여 조직화하고, 파일 간의 관계를 관리합니다.</li>
<li><strong>보안 및 권한 관리</strong>: 사용자와 그룹별로 파일에 대한 접근 권한을 설정할 수 있습니다.</li>
<li><strong>저널링</strong>: 시스템 충돌이나 전원 장애 시 데이터 손실을 방지하기 위해 변경 사항을 기록합니다.</li>
<li><strong>에러 탐지 및 복구</strong>: 파일 시스템 오류를 탐지하고 복구하는 메커니즘을 포함합니다.</li>
</ol>
<h3 id="파일-시스템-비교"><a href="#파일-시스템-비교" class="headerlink" title="파일 시스템 비교"></a>파일 시스템 비교</h3><table>
<thead>
<tr>
<th>파일 시스템</th>
<th>주 사용 운영 체제</th>
<th>최대 파일 크기</th>
<th>저널링</th>
<th>주요 특징</th>
</tr>
</thead>
<tbody><tr>
<td>NTFS</td>
<td>윈도우</td>
<td>16EB</td>
<td>예</td>
<td>보안, 압축, 대용량 파일 지원</td>
</tr>
<tr>
<td>FAT32</td>
<td>윈도우, 리눅스, 맥</td>
<td>4GB</td>
<td>아니요</td>
<td>높은 호환성, 작은 파일 시스템 적합</td>
</tr>
<tr>
<td>ext4</td>
<td>리눅스</td>
<td>1EB</td>
<td>예</td>
<td>저널링, 큰 파일 및 파일 시스템 지원</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>System</category>
        <category>Storage</category>
      </categories>
      <tags>
        <tag>파일시스템</tag>
        <tag>NFS</tag>
        <tag>NTFS</tag>
        <tag>스토리지</tag>
      </tags>
  </entry>
  <entry>
    <title>헬로 월드</title>
    <url>/1970/01/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>튜토리얼</tag>
        <tag>시작하기</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA 리포지토리와 매퍼 비교</title>
    <url>/2024/07/07/jpa-repository-vs-mapper-comparison/</url>
    <content><![CDATA[<h1 id="JPA에서-Repository와-Mapper-비교"><a href="#JPA에서-Repository와-Mapper-비교" class="headerlink" title="JPA에서 Repository와 Mapper 비교"></a>JPA에서 Repository와 Mapper 비교</h1><p>JPA (Java Persistence API)에서는 Repository와 Mapper 두 가지 주요 데이터 액세스 방법이 있으며, 어떤 것을 선택해야 하는지는 프로젝트의 요구 사항과 특성에 따라 다를 수 있습니다. 아래에서 Repository와 Mapper를 비교하고, Mapper를 사용하는 케이스에 대해 설명하겠습니다.</p>
<h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><ul>
<li><strong>Repository</strong>는 JPA를 기반으로 하는 ORM(Object-Relational Mapping) 기술을 사용하는 대표적인 방법입니다.</li>
<li>JPA Repository를 사용하면 데이터베이스와 객체 간의 매핑을 자동으로 처리하므로, 객체 지향적인 방식으로 데이터를 다루기 용이합니다.</li>
<li>CRUD(Create, Read, Update, Delete) 작업을 쉽게 수행할 수 있으며, Query Methods를 사용하여 복잡한 검색 쿼리를 생성할 수 있습니다.</li>
<li>일반적으로 도메인 객체와 JPA 엔티티를 직접 사용하는 방식으로 데이터 액세스를 수행합니다.</li>
</ul>
<h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><ul>
<li><strong>Mapper</strong>는 SQL 직접 사용이 가능하며, MyBatis와 같은 데이터베이스 액세스 프레임워크를 사용하는 방법입니다.</li>
<li>Repository와는 다르게 SQL 쿼리를 직접 작성하고 매핑을 수동으로 처리해야 합니다.</li>
<li>복잡한 SQL 쿼리를 작성하고 최적화할 때 유용하며, Repository로 처리하기 어려운 성능 최적화 작업을 수행할 수 있습니다.</li>
<li>이미 존재하는 데이터베이스 스키마와의 통합이 필요한 경우나, 기존 프로젝트의 데이터 액세스 레이어를 대체할 때 사용하기 좋습니다.</li>
</ul>
<h2 id="Repository와-Mapper-비교"><a href="#Repository와-Mapper-비교" class="headerlink" title="Repository와 Mapper 비교"></a>Repository와 Mapper 비교</h2><table>
<thead>
<tr>
<th>항목</th>
<th>Repository</th>
<th>Mapper</th>
</tr>
</thead>
<tbody><tr>
<td>사용 기술</td>
<td>JPA, Hibernate 등 ORM 프레임워크</td>
<td>MyBatis 등 SQL 매퍼 프레임워크</td>
</tr>
<tr>
<td>데이터 매핑 방식</td>
<td>자동 매핑</td>
<td>수동 매핑</td>
</tr>
<tr>
<td>쿼리 작성 방식</td>
<td>메서드 이름 기반, JPQL</td>
<td>직접 SQL 작성</td>
</tr>
<tr>
<td>CRUD 작업</td>
<td>쉽게 수행 가능</td>
<td>직접 쿼리 작성 필요</td>
</tr>
<tr>
<td>성능 최적화</td>
<td>ORM 최적화에 의존</td>
<td>직접 최적화 가능</td>
</tr>
<tr>
<td>복잡한 쿼리 처리</td>
<td>어려울 수 있음</td>
<td>유연하게 처리 가능</td>
</tr>
<tr>
<td>기존 DB 스키마 통합</td>
<td>제한적</td>
<td>유연하게 통합 가능</td>
</tr>
<tr>
<td>객체 지향적 접근</td>
<td>강력한 객체 지향 지원</td>
<td>SQL 중심 접근</td>
</tr>
</tbody></table>
<h2 id="Mapper를-사용하는-케이스"><a href="#Mapper를-사용하는-케이스" class="headerlink" title="Mapper를 사용하는 케이스"></a>Mapper를 사용하는 케이스</h2><ol>
<li><strong>복잡한 SQL 쿼리</strong>: 만약 프로젝트에서 복잡한 데이터베이스 쿼리를 자주 실행해야 하거나, 특정 비즈니스 로직에 맞춘 맞춤형 쿼리를 사용해야 하는 경우, Mapper를 사용하면 더 유연하게 대처할 수 있습니다.</li>
<li><strong>레거시 시스템 통합</strong>: 이미 존재하는 데이터베이스와 통합해야 할 때, Mapper를 사용하여 기존 스키마와의 매핑을 수동으로 처리할 수 있습니다.</li>
<li><strong>성능 최적화</strong>: Repository로는 성능 최적화를 수행하기 어려운 경우, Mapper를 사용하여 데이터베이스 액세스 작업을 최적화할 수 있습니다.</li>
<li><strong>특정 데이터베이스 기능 활용</strong>: Mapper를 사용하면 특정 데이터베이스 특성을 직접 활용할 수 있으므로, 특정 데이터베이스에 종속적인 작업을 수행해야 하는 경우 유용합니다.</li>
</ol>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>Repository와 Mapper를 혼합해서 사용하는 것도 가능합니다. 프로젝트의 요구 사항에 따라서 Repository를 사용하여 기본적인 데이터 액세스를 처리하고, Mapper를 사용하여 복잡한 쿼리나 특정 데이터베이스 작업을 수행하는 것도 가능합니다.</p>
]]></content>
      <categories>
        <category>Backend</category>
        <category>Java</category>
        <category>Database</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>MyBatis</tag>
        <tag>ORM</tag>
        <tag>데이터베이스</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>운영체제 스케줄링 알고리즘</title>
    <url>/2024/07/11/os-scheduling-algorithms-md/</url>
    <content><![CDATA[<h1 id="OS-스케줄링"><a href="#OS-스케줄링" class="headerlink" title="OS 스케줄링"></a>OS 스케줄링</h1><p>운영 체제(OS, Operating System) 스케줄링은 시스템의 자원을 효율적으로 사용하고, 사용자에게 공정한 서비스 제공을 목적으로 프로세스나 스레드의 실행 순서를 결정하는 방법이다. 스케줄링 알고리즘은 CPU, 메모리, 디스크 I&#x2F;O 등의 자원을 어떤 순서로 할당할지를 결정한다.</p>
<h2 id="스케줄링의-목표"><a href="#스케줄링의-목표" class="headerlink" title="스케줄링의 목표"></a>스케줄링의 목표</h2><ul>
<li><strong>효율성</strong>: 자원의 최대한 활용</li>
<li><strong>공정성</strong>: 모든 프로세스가 공정하게 자원을 사용할 수 있도록 보장</li>
<li><strong>응답 시간 최소화</strong>: 사용자에게 빠른 응답 시간 제공</li>
<li><strong>처리량 최대화</strong>: 주어진 시간 내에 최대한 많은 작업 처리</li>
<li><strong>대기 시간 최소화</strong>: 프로세스가 대기하는 시간을 최소화</li>
<li><strong>우선순위 보장</strong>: 중요하거나 우선순위가 높은 작업을 먼저 처리</li>
</ul>
<h2 id="스케줄링의-종류"><a href="#스케줄링의-종류" class="headerlink" title="스케줄링의 종류"></a>스케줄링의 종류</h2><h3 id="1-선점형-스케줄링-Preemptive-Scheduling"><a href="#1-선점형-스케줄링-Preemptive-Scheduling" class="headerlink" title="1. 선점형 스케줄링 (Preemptive Scheduling)"></a>1. 선점형 스케줄링 (Preemptive Scheduling)</h3><p>운영 체제가 프로세스를 강제로 중단시키고 다른 프로세스로 교체할 수 있는 스케줄링 방법.</p>
<ul>
<li><strong>라운드 로빈 (Round Robin)</strong>: 각 프로세스는 동일한 시간 할당을 받아 실행되고, 할당 시간이 끝나면 다음 프로세스로 교체된다.</li>
<li><strong>SRT (Shortest Remaining Time)</strong>: 남은 실행 시간이 가장 짧은 프로세스를 우선 실행한다.</li>
<li><strong>다단계 큐 (Multilevel Queue)</strong>: 프로세스를 여러 우선순위 큐로 나누어 각각의 큐에서 독립적으로 스케줄링한다.</li>
<li><strong>다단계 피드백 큐 (Multilevel Feedback Queue)</strong>: 프로세스가 CPU를 많이 사용하면 낮은 우선순위 큐로 이동시키고, 적게 사용하면 높은 우선순위 큐로 이동시킨다.</li>
</ul>
<h3 id="2-비선점형-스케줄링-Non-preemptive-Scheduling"><a href="#2-비선점형-스케줄링-Non-preemptive-Scheduling" class="headerlink" title="2. 비선점형 스케줄링 (Non-preemptive Scheduling)"></a>2. 비선점형 스케줄링 (Non-preemptive Scheduling)</h3><p>프로세스가 자발적으로 CPU를 반환할 때까지 실행을 계속하는 스케줄링 방법.</p>
<ul>
<li><strong>FCFS (First-Come, First-Served)</strong>: 먼저 도착한 프로세스를 먼저 실행한다.</li>
<li><strong>SJF (Shortest Job First)</strong>: 실행 시간이 가장 짧은 프로세스를 먼저 실행한다.</li>
<li><strong>우선순위 스케줄링 (Priority Scheduling)</strong>: 우선순위가 높은 프로세스를 먼저 실행한다.</li>
<li><strong>HRRN (Highest Response Ratio Next)</strong>: 응답률이 가장 높은 프로세스를 먼저 실행한다.</li>
</ul>
<h2 id="컨텍스트-스위칭-오버헤드"><a href="#컨텍스트-스위칭-오버헤드" class="headerlink" title="컨텍스트 스위칭 오버헤드"></a>컨텍스트 스위칭 오버헤드</h2><p>컨텍스트 스위칭은 CPU가 현재 실행 중인 프로세스의 상태(컨텍스트)를 저장하고, 다른 프로세스의 상태를 불러오는 작업이다. 이 과정은 다음과 같은 단계를 포함한다:</p>
<ol>
<li>현재 실행 중인 프로세스의 레지스터와 프로그램 카운터 값을 저장</li>
<li>다른 프로세스의 저장된 레지스터와 프로그램 카운터 값을 복원</li>
<li>메모리 매핑 테이블 등의 시스템 자원을 새 프로세스에 맞게 조정</li>
</ol>
<p>컨텍스트 스위칭 오버헤드는 이 과정에서 발생하는 시간 및 자원 소모를 의미한다. 잦은 컨텍스트 스위칭은 시스템 성능을 저하시킬 수 있다. 특히, 다음과 같은 이유로 오버헤드가 발생한다:</p>
<ul>
<li><strong>CPU 레지스터 저장 및 복원</strong>: 레지스터를 저장하고 복원하는 작업이 빈번하게 발생</li>
<li><strong>캐시 미스 증가</strong>: 프로세스 전환 시 캐시 메모리에 저장된 데이터가 무효화되어 캐시 미스가 증가</li>
<li><strong>메모리 매핑 테이블 업데이트</strong>: 메모리 관리 유닛(MMU)의 테이블을 새 프로세스에 맞게 업데이트</li>
</ul>
<h2 id="스케줄링-알고리즘-비교"><a href="#스케줄링-알고리즘-비교" class="headerlink" title="스케줄링 알고리즘 비교"></a>스케줄링 알고리즘 비교</h2><table>
<thead>
<tr>
<th>알고리즘</th>
<th>선점형&#x2F;비선점형</th>
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody><tr>
<td>FCFS</td>
<td>비선점형</td>
<td>구현이 간단하고 공정함</td>
<td>대기 시간이 길어질 수 있음</td>
</tr>
<tr>
<td>SJF</td>
<td>비선점형</td>
<td>평균 대기 시간이 최소화됨</td>
<td>실행 시간을 미리 알기 어려움</td>
</tr>
<tr>
<td>Priority Scheduling</td>
<td>비선점형</td>
<td>중요한 작업을 우선 처리</td>
<td>기아 현상이 발생할 수 있음</td>
</tr>
<tr>
<td>Round Robin</td>
<td>선점형</td>
<td>응답 시간이 일정하고 공정함</td>
<td>컨텍스트 스위칭 오버헤드가 있음</td>
</tr>
<tr>
<td>SRT</td>
<td>선점형</td>
<td>짧은 작업이 빨리 끝남</td>
<td>컨텍스트 스위칭 오버헤드가 있음</td>
</tr>
<tr>
<td>Multilevel Queue</td>
<td>선점형</td>
<td>우선순위에 따라 작업을 분리하여 처리</td>
<td>특정 큐에 작업이 몰릴 수 있음</td>
</tr>
<tr>
<td>Multilevel Feedback Queue</td>
<td>선점형</td>
<td>다양한 작업 특성에 대응 가능</td>
<td>구현이 복잡하고 컨텍스트 스위칭 오버헤드가 있음</td>
</tr>
</tbody></table>
<p>각 스케줄링 알고리즘은 시스템의 목표와 상황에 따라 적절하게 선택되어야 한다.</p>
]]></content>
      <categories>
        <category>System</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>운영체제</tag>
        <tag>스케줄링</tag>
        <tag>알고리즘</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI 7 계층 모델</title>
    <url>/2024/07/10/osi-7-layer-model-md/</url>
    <content><![CDATA[<h1 id="OSI-7-Layer-Model"><a href="#OSI-7-Layer-Model" class="headerlink" title="OSI 7 Layer Model"></a>OSI 7 Layer Model</h1><p>OSI (Open Systems Interconnection) 모델은 네트워크 프로토콜을 이해하고 구현하는 데 사용되는 개념적 프레임워크로, 7개의 계층으로 구성되어 있습니다. 각 계층은 특정 기능을 수행하며, 바로 위와 아래의 계층과 통신합니다. 다음은 각 계층에 대한 설명입니다.</p>
<h2 id="1-물리-계층-Physical-Layer"><a href="#1-물리-계층-Physical-Layer" class="headerlink" title="1. 물리 계층 (Physical Layer)"></a>1. 물리 계층 (Physical Layer)</h2><ul>
<li><strong>기능</strong>: 장치 간의 물리적 연결을 담당. 전기적 신호, 광 신호, 라디오 신호 등의 형태로 데이터를 전송.</li>
<li><strong>예</strong>: 케이블, 스위치, 허브</li>
</ul>
<h2 id="2-데이터-링크-계층-Data-Link-Layer"><a href="#2-데이터-링크-계층-Data-Link-Layer" class="headerlink" title="2. 데이터 링크 계층 (Data Link Layer)"></a>2. 데이터 링크 계층 (Data Link Layer)</h2><ul>
<li><strong>기능</strong>: 물리 계층에서 오류 없는 데이터 전송을 보장. MAC 주소를 사용하여 장치 간 데이터를 전송하며, 프레임을 형성하고 오류 검출을 수행.</li>
<li><strong>예</strong>: 이더넷, 스위치</li>
</ul>
<h2 id="3-네트워크-계층-Network-Layer"><a href="#3-네트워크-계층-Network-Layer" class="headerlink" title="3. 네트워크 계층 (Network Layer)"></a>3. 네트워크 계층 (Network Layer)</h2><ul>
<li><strong>기능</strong>: 데이터를 목적지까지 전달하는 경로를 결정. IP 주소를 사용하여 패킷을 라우팅하고 네트워크 간 데이터 전송을 관리.</li>
<li><strong>예</strong>: IP, 라우터</li>
</ul>
<h2 id="4-전송-계층-Transport-Layer"><a href="#4-전송-계층-Transport-Layer" class="headerlink" title="4. 전송 계층 (Transport Layer)"></a>4. 전송 계층 (Transport Layer)</h2><ul>
<li><strong>기능</strong>: 종단 간 데이터 전송을 담당. TCP, UDP 프로토콜을 사용하여 데이터의 신뢰성, 흐름 제어 및 오류 복구를 관리.</li>
<li><strong>예</strong>: TCP, UDP</li>
</ul>
<h2 id="5-세션-계층-Session-Layer"><a href="#5-세션-계층-Session-Layer" class="headerlink" title="5. 세션 계층 (Session Layer)"></a>5. 세션 계층 (Session Layer)</h2><ul>
<li><strong>기능</strong>: 통신 세션을 설정, 관리 및 종료. 세션 복구와 체크포인트를 제공하여 통신 중단 시 재개 가능.</li>
<li><strong>예</strong>: NetBIOS, PPTP</li>
</ul>
<h2 id="6-표현-계층-Presentation-Layer"><a href="#6-표현-계층-Presentation-Layer" class="headerlink" title="6. 표현 계층 (Presentation Layer)"></a>6. 표현 계층 (Presentation Layer)</h2><ul>
<li><strong>기능</strong>: 데이터 형식 변환, 암호화, 압축 등의 기능을 수행. 애플리케이션 계층과 세션 계층 간 데이터 표현을 관리.</li>
<li><strong>예</strong>: SSL&#x2F;TLS, JPEG, MPEG</li>
</ul>
<h2 id="7-응용-계층-Application-Layer"><a href="#7-응용-계층-Application-Layer" class="headerlink" title="7. 응용 계층 (Application Layer)"></a>7. 응용 계층 (Application Layer)</h2><ul>
<li><strong>기능</strong>: 최종 사용자와 직접 상호작용하는 애플리케이션 서비스 제공. 다양한 네트워크 서비스와 애플리케이션을 지원.</li>
<li><strong>예</strong>: HTTP, FTP, SMTP, DNS</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
        <category>Theory</category>
      </categories>
      <tags>
        <tag>OSI</tag>
        <tag>네트워크</tag>
        <tag>프로토콜</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>세션, 쿠키, JWT 비교</title>
    <url>/2024/07/18/session-cookie-jwt-comparison-md/</url>
    <content><![CDATA[<h1 id="세션-쿠키-JWT-JSON-Web-Token-의-설명-및-비교"><a href="#세션-쿠키-JWT-JSON-Web-Token-의-설명-및-비교" class="headerlink" title="세션, 쿠키, JWT(JSON Web Token)의 설명 및 비교"></a>세션, 쿠키, JWT(JSON Web Token)의 설명 및 비교</h1><h2 id="세션-Session-과-쿠키-Cookie-설명"><a href="#세션-Session-과-쿠키-Cookie-설명" class="headerlink" title="세션(Session)과 쿠키(Cookie) 설명"></a>세션(Session)과 쿠키(Cookie) 설명</h2><h3 id="세션-Session"><a href="#세션-Session" class="headerlink" title="세션(Session)"></a>세션(Session)</h3><ul>
<li><strong>개념</strong>: 서버에서 생성된 세션 ID를 클라이언트의 쿠키에 저장하여 인증을 관리하는 방식.</li>
<li><strong>작동 방식</strong>:<ul>
<li>사용자가 로그인하면 서버는 고유한 세션 ID를 생성한다.</li>
<li>이 세션 ID는 서버의 세션 저장소에 사용자 정보와 함께 저장된다.</li>
<li>서버는 이 세션 ID를 클라이언트의 쿠키에 저장한다.</li>
<li>이후 클라이언트가 서버에 요청을 보낼 때마다 이 쿠키를 함께 전송한다.</li>
<li>서버는 세션 저장소에서 세션 ID를 확인하여 사용자를 인증한다.</li>
</ul>
</li>
<li><strong>보안</strong>:<ul>
<li>세션 쿠키는 주로 서버 측에서 관리되므로, 세션 탈취(Session Hijacking)를 방지하기 위해 HTTPS를 사용하여 통신을 암호화한다.</li>
<li>서버가 세션을 관리하므로, 세션 만료 시간 등을 서버에서 설정할 수 있다.</li>
<li>XSS 공격에 취약할 수 있으므로, HttpOnly, Secure, SameSite 속성을 설정하여 보안을 강화할 수 있다.</li>
</ul>
</li>
</ul>
<h3 id="쿠키-Cookie"><a href="#쿠키-Cookie" class="headerlink" title="쿠키(Cookie)"></a>쿠키(Cookie)</h3><ul>
<li><strong>개념</strong>: 클라이언트 측에서 데이터를 저장하기 위해 사용하는 작은 파일로, 서버와 클라이언트 간의 상태를 유지하는 데 사용된다.</li>
<li><strong>작동 방식</strong>:<ul>
<li>서버가 클라이언트에게 Set-Cookie 헤더를 통해 쿠키를 전송한다.</li>
<li>클라이언트는 이 쿠키를 저장하고, 이후 서버에 요청을 보낼 때마다 쿠키를 함께 전송한다.</li>
<li>서버는 쿠키를 확인하여 필요한 정보를 처리한다.</li>
</ul>
</li>
<li><strong>보안</strong>:<ul>
<li>쿠키는 클라이언트 측에 저장되므로, XSS 공격에 취약할 수 있다.</li>
<li>Secure 속성을 사용하여 HTTPS 연결에서만 전송되도록 할 수 있다.</li>
<li>HttpOnly 속성을 사용하여 자바스크립트에서 접근하지 못하도록 할 수 있다.</li>
<li>SameSite 속성을 사용하여 CSRF 공격을 방지할 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="JWT-JSON-Web-Token-설명"><a href="#JWT-JSON-Web-Token-설명" class="headerlink" title="JWT(JSON Web Token) 설명"></a>JWT(JSON Web Token) 설명</h2><ul>
<li><strong>개념</strong>: JSON Web Token(JWT)는 JSON 객체를 사용해 파티 간에 정보를 안전하게 전송하기 위한 개방형 표준(RFC 7519)이다.</li>
<li><strong>구성 요소</strong>:<ul>
<li><strong>Header</strong>: 토큰의 타입(JWT)과 해싱 알고리즘 정보를 포함.</li>
<li><strong>Payload</strong>: 토큰에 담을 정보(클레임)를 포함.</li>
<li><strong>Signature</strong>: 토큰의 무결성을 검증하기 위한 서명.</li>
</ul>
</li>
<li><strong>작동 방식</strong>:<ul>
<li>클라이언트가 인증을 요청하면 서버는 클라이언트의 정보를 바탕으로 JWT를 생성해 응답한다.</li>
<li>클라이언트는 서버로부터 받은 JWT를 저장하고, 이후 요청 시마다 HTTP 헤더에 JWT를 포함해 전송한다.</li>
<li>서버는 전송받은 JWT의 서명을 검증하고, 페이로드의 정보를 바탕으로 클라이언트를 인증한다.</li>
</ul>
</li>
</ul>
<h2 id="JWT의-장점과-보안-우려-사항"><a href="#JWT의-장점과-보안-우려-사항" class="headerlink" title="JWT의 장점과 보안 우려 사항"></a>JWT의 장점과 보안 우려 사항</h2><h3 id="JWT의-장점"><a href="#JWT의-장점" class="headerlink" title="JWT의 장점"></a>JWT의 장점</h3><h4 id="1-상태-비저장-Stateless"><a href="#1-상태-비저장-Stateless" class="headerlink" title="1. 상태 비저장(Stateless)"></a>1. 상태 비저장(Stateless)</h4><ul>
<li><strong>서버 부하 감소</strong>: JWT는 서버에 상태를 저장하지 않으므로, 각 요청을 처리하기 위해 서버가 사용자 상태를 유지할 필요가 없다. 이로 인해 서버 부하가 감소하고, 확장성이 향상된다.</li>
<li><strong>확장성</strong>: 서버 간 세션 동기화가 필요하지 않아, 수평 확장(horizontal scaling)이 용이하다.</li>
</ul>
<h4 id="2-유연성"><a href="#2-유연성" class="headerlink" title="2. 유연성"></a>2. 유연성</h4><ul>
<li><strong>다양한 사용 사례</strong>: JWT는 웹, 모바일, IoT 등 다양한 클라이언트에서 사용할 수 있으며, OAuth 2.0과 같은 인증 프로토콜에서도 널리 사용된다.</li>
<li><strong>자체 포함</strong>: JWT는 페이로드에 필요한 정보를 포함하므로, 서버는 추가 조회 없이 토큰만으로 인증을 처리할 수 있다.</li>
</ul>
<h4 id="3-보안"><a href="#3-보안" class="headerlink" title="3. 보안"></a>3. 보안</h4><ul>
<li><strong>서명 및 암호화</strong>: JWT는 서명(Signature)을 통해 위변조를 방지할 수 있으며, 필요에 따라 암호화할 수 있어 안전한 정보 전송이 가능하다.</li>
<li><strong>단기 사용</strong>: 토큰의 유효 기간을 설정하여 짧은 기간 동안만 유효하도록 함으로써 보안을 강화할 수 있다.</li>
</ul>
<h4 id="4-표준화"><a href="#4-표준화" class="headerlink" title="4. 표준화"></a>4. 표준화</h4><ul>
<li><strong>광범위한 지원</strong>: JWT는 RFC 7519 표준을 따르며, 다양한 프로그래밍 언어와 프레임워크에서 지원된다. 이를 통해 다양한 환경에서 일관된 방식으로 인증을 구현할 수 있다.</li>
</ul>
<h4 id="5-전송-효율성"><a href="#5-전송-효율성" class="headerlink" title="5. 전송 효율성"></a>5. 전송 효율성</h4><ul>
<li><strong>경량성</strong>: JWT는 JSON 형식의 텍스트로 구성되며, Base64 URL 인코딩을 통해 크기가 작고, HTTP 헤더를 통해 쉽게 전송할 수 있다.</li>
</ul>
<h4 id="6-디버깅-및-테스트-용이"><a href="#6-디버깅-및-테스트-용이" class="headerlink" title="6. 디버깅 및 테스트 용이"></a>6. 디버깅 및 테스트 용이</h4><ul>
<li><strong>사람이 읽을 수 있는 형식</strong>: JWT는 Base64 URL 인코딩된 JSON 형식이므로, 디코딩하여 사람도 쉽게 읽을 수 있어 디버깅과 테스트가 용이하다.</li>
<li><strong>온라인 도구</strong>: 다양한 온라인 도구를 사용하여 JWT를 디코딩하고 검증할 수 있다.</li>
</ul>
<h4 id="7-클라이언트-측-저장"><a href="#7-클라이언트-측-저장" class="headerlink" title="7. 클라이언트 측 저장"></a>7. 클라이언트 측 저장</h4><ul>
<li><strong>유연한 저장 옵션</strong>: JWT는 클라이언트 측 로컬 저장소(localStorage, sessionStorage)나 쿠키에 저장할 수 있어 다양한 상황에 맞게 사용할 수 있다.</li>
<li><strong>세션 유지</strong>: 브라우저를 닫았다 열어도 로컬 저장소에 저장된 JWT를 통해 세션을 유지할 수 있다.</li>
</ul>
<h3 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h3><p>JWT의 장점들을 표로 요약하면 다음과 같다:</p>
<table>
<thead>
<tr>
<th>장점</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>상태 비저장</td>
<td>서버 상태 유지 불필요, 서버 부하 감소, 확장성 향상</td>
</tr>
<tr>
<td>유연성</td>
<td>다양한 클라이언트와 프로토콜에서 사용 가능, 자체 포함된 정보</td>
</tr>
<tr>
<td>보안</td>
<td>서명 및 암호화를 통해 위변조 방지, 단기 사용 가능</td>
</tr>
<tr>
<td>표준화</td>
<td>RFC 7519 표준, 다양한 언어와 프레임워크에서 지원</td>
</tr>
<tr>
<td>전송 효율성</td>
<td>경량성, HTTP 헤더를 통해 쉽게 전송 가능</td>
</tr>
<tr>
<td>디버깅 및 테스트</td>
<td>사람 읽을 수 있는 형식, 다양한 온라인 도구 지원</td>
</tr>
<tr>
<td>클라이언트 측 저장</td>
<td>로컬 저장소나 쿠키에 저장 가능, 브라우저 재시작 시 세션 유지 가능</td>
</tr>
</tbody></table>
<h2 id="JWT의-보안-우려-사항-및-대응-방법"><a href="#JWT의-보안-우려-사항-및-대응-방법" class="headerlink" title="JWT의 보안 우려 사항 및 대응 방법"></a>JWT의 보안 우려 사항 및 대응 방법</h2><h3 id="1-전송-중-탈취-MITM-공격"><a href="#1-전송-중-탈취-MITM-공격" class="headerlink" title="1. 전송 중 탈취(MITM 공격)"></a>1. 전송 중 탈취(MITM 공격)</h3><ul>
<li><strong>우려</strong>: 토큰이 전송 중에 가로채질 수 있다.</li>
<li><strong>대응 방법</strong>: 항상 HTTPS를 사용하여 전송 데이터를 암호화한다. 이를 통해 전송 중 토큰이 가로채지지 않도록 보호할 수 있다.</li>
</ul>
<h3 id="2-토큰-저장소-공격"><a href="#2-토큰-저장소-공격" class="headerlink" title="2. 토큰 저장소 공격"></a>2. 토큰 저장소 공격</h3><ul>
<li><strong>우려</strong>: 클라이언트 측에 저장된 토큰이 악의적인 스크립트에 의해 접근될 수 있다.</li>
<li><strong>대응 방법</strong>:<ul>
<li><strong>HttpOnly 쿠키 사용</strong>: XSS 공격을 방지하기 위해 HttpOnly 속성을 설정하여 클라이언트의 자바스크립트에서 쿠키에 접근하지 못하도록 한다.</li>
<li><strong>Secure 쿠키 사용</strong>: HTTPS 연결을 통해서만 쿠키가 전송되도록 Secure 속성을 설정한다.</li>
<li><strong>SameSite 쿠키 사용</strong>: CSRF 공격을 방지하기 위해 SameSite 속성을 설정한다.</li>
<li><strong>로컬 스토리지 사용 시 주의</strong>: 로컬 스토리지는 XSS 공격에 취약하므로, 가능한 경우 쿠키를 사용하고, XSS 방어 코드를 적용한다.</li>
</ul>
</li>
</ul>
<h3 id="3-토큰-탈취-후-재사용"><a href="#3-토큰-탈취-후-재사용" class="headerlink" title="3. 토큰 탈취 후 재사용"></a>3. 토큰 탈취 후 재사용</h3><ul>
<li><strong>우려</strong>: 토큰이 탈취되면 공격자가 이를 사용해 인증된 사용자로 행동할 수 있다.</li>
<li><strong>대응 방법</strong>:<ul>
<li><strong>짧은 유효 기간 설정</strong>: 토큰의 유효 기간을 짧게 설정하고, 자동 갱신을 통해 새 토큰을 발급받도록 한다.</li>
<li><strong>토큰 무효화</strong>: 서버 측에서 블랙리스트를 유지하여 탈취된 토큰을 무효화할 수 있는 방법을 구현한다.</li>
</ul>
</li>
</ul>
<h3 id="4-토큰-변조"><a href="#4-토큰-변조" class="headerlink" title="4. 토큰 변조"></a>4. 토큰 변조</h3><ul>
<li><strong>우려</strong>: 공격자가 토큰을 변조하여 권한을 상승시킬 수 있다.</li>
<li><strong>대응 방법</strong>:<ul>
<li><strong>서명 검증</strong>: 토큰을 수신한 서버는 항상 서명을 검증하여 변조 여부를 확인한다.</li>
<li><strong>강력한 비밀 키 사용</strong>: 서명을 위한 비밀 키를 안전하게 관리하고, 충분히 복잡하고 예측 불가능한 값을 사용한다.</li>
</ul>
</li>
</ul>
<h3 id="5-페이로드-정보-유출"><a href="#5-페이로드-정보-유출" class="headerlink" title="5. 페이로드 정보 유출"></a>5. 페이로드 정보 유출</h3><ul>
<li><strong>우려</strong>: 페이로드는 Base64 URL 인코딩만 되어 있어 누구나 디코딩할 수 있다.</li>
<li><strong>대응 방법</strong>:<ul>
<li><strong>민감한 정보 포함 금지</strong>: JWT 페이로드에는 민감한 정보를 포함하지 않는다.</li>
<li><strong>암호화</strong>: 필요할 경우 JWE(JSON Web Encryption)를 사용하여 토큰 자체를 암호화한다.</li>
</ul>
</li>
</ul>
<h3 id="요약-1"><a href="#요약-1" class="headerlink" title="요약"></a>요약</h3><p>JWT의 보안 취약점을 표로 요약하고 대응 방법을 정리하면 다음과 같다:</p>
<table>
<thead>
<tr>
<th>보안 우려 사항</th>
<th>대응 방법</th>
</tr>
</thead>
<tbody><tr>
<td>전송 중 탈취</td>
<td>HTTPS 사용</td>
</tr>
<tr>
<td>토큰 저장소 공격</td>
<td>HttpOnly, Secure, SameSite 쿠키 사용, XSS 방어 코드 적용</td>
</tr>
<tr>
<td>토큰 탈취 후 재사용</td>
<td>짧은 유효 기간 설정, 토큰 무효화 시스템 구현</td>
</tr>
<tr>
<td>토큰 변조</td>
<td>서명 검증, 강력한 비밀 키 사용</td>
</tr>
<tr>
<td>페이로드 정보 유출</td>
<td>민감한 정보 포함 금지, 필요 시 JWE를 사용한 토큰 암호화</td>
</tr>
</tbody></table>
<h2 id="세션-쿠키와-JWT-비교"><a href="#세션-쿠키와-JWT-비교" class="headerlink" title="세션, 쿠키와 JWT 비교"></a>세션, 쿠키와 JWT 비교</h2><h3 id="세션과-JWT-비교"><a href="#세션과-JWT-비교" class="headerlink" title="세션과 JWT 비교"></a>세션과 JWT 비교</h3><table>
<thead>
<tr>
<th>항목</th>
<th>세션(Session)</th>
<th>JWT(JSON Web Token)</th>
</tr>
</thead>
<tbody><tr>
<td>상태 유지</td>
<td>서버에서 세션 상태를 저장</td>
<td>상태 비저장, 서버에서 상태를 저장하지 않음</td>
</tr>
<tr>
<td>확장성</td>
<td>서버 간 세션 동기화 필요</td>
<td>서버 간 동기화 불필요, 확장성 용이</td>
</tr>
<tr>
<td>저장 위치</td>
<td>서버 측 세션 저장소</td>
<td>클라이언트 측 (로컬 저장소, 쿠키)</td>
</tr>
<tr>
<td>보안</td>
<td>세션 탈취 방지를 위해 HTTPS 필요</td>
<td>서명 및 암호화를 통해 위변조 방지</td>
</tr>
<tr>
<td>유효 기간</td>
<td>서버에서 세션 만료 시간 설정 가능</td>
<td>짧은 유효 기간 설정 가능</td>
</tr>
</tbody></table>
<h3 id="쿠키와-JWT-비교"><a href="#쿠키와-JWT-비교" class="headerlink" title="쿠키와 JWT 비교"></a>쿠키와 JWT 비교</h3><table>
<thead>
<tr>
<th>항목</th>
<th>쿠키(Cookie)</th>
<th>JWT(JSON Web Token)</th>
</tr>
</thead>
<tbody><tr>
<td>저장 위치</td>
<td>클라이언트 측 (쿠키)</td>
<td>클라이언트 측 (로컬 저장소, 쿠키)</td>
</tr>
<tr>
<td>데이터 포함</td>
<td>주로 세션 ID와 같은 간단한 데이터 포함</td>
<td>페이로드에 다양한 정보 포함 가능</td>
</tr>
<tr>
<td>보안</td>
<td>XSS, CSRF 공격에 취약할 수 있음</td>
<td>서명 및 암호화를 통해 위변조 방지</td>
</tr>
<tr>
<td>유효 기간</td>
<td>쿠키 만료 시간 설정 가능</td>
<td>짧은 유효 기간 설정 가능</td>
</tr>
<tr>
<td>전송 효율성</td>
<td>크기에 제한이 있음</td>
<td>경량성, HTTP 헤더를 통해 쉽게 전송 가능</td>
</tr>
</tbody></table>
<p>이러한 비교를 통해 세션, 쿠키, JWT 각각의 장단점을 이해하고, 필요에 따라 적절한 인증 방식을 선택할 수 있다.</p>
]]></content>
      <categories>
        <category>Backend</category>
        <category>Security</category>
        <category>Authentication</category>
      </categories>
      <tags>
        <tag>세션</tag>
        <tag>쿠키</tag>
        <tag>JWT</tag>
        <tag>인증</tag>
        <tag>보안</tag>
      </tags>
  </entry>
  <entry>
    <title>공개 키와 비밀 키 암호화 이해</title>
    <url>/2024/07/07/understanding-public-private-key-encryption/</url>
    <content><![CDATA[<h1 id="공개키와-개인키-암호화에-대한-이해"><a href="#공개키와-개인키-암호화에-대한-이해" class="headerlink" title="공개키와 개인키 암호화에 대한 이해"></a>공개키와 개인키 암호화에 대한 이해</h1><p>공개키 암호화는 데이터를 안전하게 전송하고, 디지털 서명을 생성하는 데 중요한 비대칭 키 암호화 방식입니다. 이 방식은 공개키와 개인키라는 두 개의 키를 사용하여 작동합니다.</p>
<h2 id="공개키-Public-Key"><a href="#공개키-Public-Key" class="headerlink" title="공개키 (Public Key)"></a>공개키 (Public Key)</h2><ul>
<li><strong>접근성</strong>: 누구에게나 공개 가능한 키입니다.</li>
<li><strong>용도</strong>: 데이터 암호화에 사용됩니다.</li>
<li><strong>보안 수준</strong>: 높은 수준의 보안을 제공합니다.</li>
<li><strong>키의 생성</strong>: 키 쌍을 생성할 때 자동으로 생성됩니다.</li>
<li><strong>저장 위치</strong>: 공개 서버, 인증서 등에 저장됩니다.</li>
</ul>
<h2 id="개인키-Private-Key"><a href="#개인키-Private-Key" class="headerlink" title="개인키 (Private Key)"></a>개인키 (Private Key)</h2><ul>
<li><strong>접근성</strong>: 소유자만 비밀로 유지해야 하는 키입니다.</li>
<li><strong>용도</strong>: 데이터 복호화 및 디지털 서명 생성에 사용됩니다.</li>
<li><strong>보안 수준</strong>: 매우 높은 수준의 보안이 필요합니다.</li>
<li><strong>키의 생성</strong>: 키 쌍을 생성할 때 자동으로 생성됩니다.</li>
<li><strong>저장 위치</strong>: 개인 디바이스나 안전한 저장소에 저장됩니다.</li>
</ul>
<p>공개키 암호화는 데이터의 기밀성과 무결성을 유지하며, 네트워크 상에서 안전한 통신을 가능하게 합니다. 이 방식은 인터넷 보안, 전자상거래, 디지털 서명 등 다양한 분야에서 중요한 역할을 합니다.</p>
]]></content>
      <categories>
        <category>Security</category>
        <category>Cryptography</category>
      </categories>
      <tags>
        <tag>보안</tag>
        <tag>암호화</tag>
        <tag>공개키</tag>
        <tag>PKI</tag>
      </tags>
  </entry>
  <entry>
    <title>시맨틱 HTML 태그 개요</title>
    <url>/2024/07/07/semantic-html-tags-overview/</url>
    <content><![CDATA[<h1 id="시맨틱-HTML-태그-소개"><a href="#시맨틱-HTML-태그-소개" class="headerlink" title="시맨틱 HTML 태그 소개"></a>시맨틱 HTML 태그 소개</h1><p>시맨틱(semantic) HTML 태그는 웹 문서의 구조와 의미를 명확히 전달하기 위해 사용됩니다. 이러한 태그들은 검색 엔진 최적화(SEO)와 웹 접근성을 향상시키는 데 도움을 줍니다. 대표적인 시맨틱 HTML 태그를 살펴보겠습니다.</p>
<h2 id="대표적인-시맨틱-HTML-태그"><a href="#대표적인-시맨틱-HTML-태그" class="headerlink" title="대표적인 시맨틱 HTML 태그"></a>대표적인 시맨틱 HTML 태그</h2><ol>
<li><strong><code>&lt;header&gt;</code></strong>: 웹 페이지나 섹션의 머리말을 정의합니다. 로고, 탐색 메뉴, 로그인 폼 등과 같은 요소를 포함할 수 있습니다.</li>
<li><strong><code>&lt;nav&gt;</code></strong>: 탐색 링크의 그룹을 정의합니다. 이는 페이지의 메인 메뉴나 사이트 내에서 중요한 링크를 담는 데 사용됩니다.</li>
<li><strong><code>&lt;main&gt;</code></strong>: 문서의 주요 콘텐츠를 정의합니다. 보통 한 페이지에 하나만 존재하며, 페이지의 핵심 내용을 담습니다.</li>
<li><strong><code>&lt;section&gt;</code></strong>: 문서나 애플리케이션의 섹션을 정의합니다. 일반적으로 제목(<code>&lt;h1&gt;</code>~&#96;<h6>&#96;)과 함께 사용되며, 관련된 콘텐츠를 그룹화합니다.</li>
<li><strong><code>&lt;article&gt;</code></strong>: 독립적으로 구성되거나 재사용 가능한 콘텐츠를 정의합니다. 뉴스 기사, 포럼 게시물, 블로그 포스트 등과 같은 콘텐츠를 담을 수 있습니다.</li>
<li><strong><code>&lt;aside&gt;</code></strong>: 본문 이외의 부가 콘텐츠를 정의합니다. 주로 사이드바나 콜아웃 박스 등에 사용되며, 부가 정보나 광고 등을 담습니다.</li>
<li><strong><code>&lt;footer&gt;</code></strong>: 문서나 섹션의 바닥글을 정의합니다. 보통 저작권 정보, 연락처 정보, 사이트 링크 등을 포함합니다.</li>
</ol>
<h2 id="시맨틱-HTML-예제-코드"><a href="#시맨틱-HTML-예제-코드" class="headerlink" title="시맨틱 HTML 예제 코드"></a>시맨틱 HTML 예제 코드</h2><p>아래는 시맨틱 HTML 태그들을 사용한 간단한 웹 페이지 예제입니다.</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Semantic HTML Example&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;header&gt;
        &lt;h1&gt;My Website&lt;/h1&gt;
        &lt;nav&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;About&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/nav&gt;
    &lt;/header&gt;

    &lt;main&gt;
        &lt;section&gt;
            &lt;h2&gt;About Us&lt;/h2&gt;
            &lt;p&gt;Welcome to our website! We provide...&lt;/p&gt;
        &lt;/section&gt;

        &lt;section&gt;
            &lt;h2&gt;Our Services&lt;/h2&gt;
            &lt;article&gt;
                &lt;h3&gt;Service 1&lt;/h3&gt;
                &lt;p&gt;Description of Service 1...&lt;/p&gt;
            &lt;/article&gt;
            &lt;article&gt;
                &lt;h3&gt;Service 2&lt;/h3&gt;
                &lt;p&gt;Description of Service 2...&lt;/p&gt;
            &lt;/article&gt;
        &lt;/section&gt;
    &lt;/main&gt;

    &lt;aside&gt;
        &lt;h2&gt;Advertisement&lt;/h2&gt;
        &lt;p&gt;Check out our special offers!&lt;/p&gt;
    &lt;/aside&gt;

    &lt;footer&gt;
        &lt;p&gt;&amp;copy; 2024 My Website. All rights reserved.&lt;/p&gt;
    &lt;/footer&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
      <categories>
        <category>Frontend</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>시맨틱</tag>
        <tag>웹 표준</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
</search>
